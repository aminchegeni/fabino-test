package ir.co.isc.spbp.blockchain.microfab.model;

import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import org.json.JSONObject;
import org.json.JSONPropertyIgnore;
import org.json.JSONPropertyName;

import java.util.Base64;
import java.util.Map;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static java.util.stream.Collectors.toUnmodifiableMap;

/**
 * Represents the state file (<code>state.json</code>) generated by
 * <a href="https://github.com/hyperledger-labs/microfab/blob/main/internal/app/microfabd/microfabd.go">Microfabd</a>.
 *
 * <p>
 * This file contains a snapshot of the identities and cryptographic material
 * managed internally by Microfab. It is typically generated when Microfab starts
 * and can be copied from the container to the host for inspection or for
 * integration with external tools.
 * </p>
 *
 * <h2>Structure of the File</h2>
 * <ul>
 *     <li><b>hash</b> – A hash value representing the integrity of the state.</li>
 *     <li><b>cas</b> – A mapping of Certificate Authorities (CAs) keyed by
 *     their organization name (e.g., <code>Orderer</code>, <code>mat</code>,
 *     <code>mb</code>, <code>parizi</code>). Each entry is an {@link Identity}
 *     object containing the CA’s certificate, private key, and metadata.</li>
 *     <li><b>tls</b> – A special {@link Identity} representing the wildcard TLS
 *     identity used by Microfab to secure communications (typically with a
 *     <code>*.127-0-0-1.nip.io</code> subject).</li>
 * </ul>
 *
 * <p>
 * <b>Note:</b> The {@code cert}, {@code private_key}, and {@code ca} fields inside
 * {@link Identity} are Base64 PEM-encoded strings. They must be decoded and
 * parsed into standard Java security objects (e.g., {@code X509Certificate},
 * {@code PrivateKey}) before use.
 * </p>
 *
 * @see Identity
 */
@Data
@Builder(builderClassName = "Builder")
public class State {

    /**
     * Integrity hash of the state file.
     * <p>
     * This hash is generated by Microfab and can be used to verify
     * that the file has not been tampered with.
     * </p>
     */
    private String hash;

    /**
     * Map of Certificate Authorities (CAs) available in the Microfab network.
     * <p>
     * The key corresponds to the organization or CA name (e.g., {@code Orderer},
     * {@code mat}, {@code mb}, {@code parizi}), and the value is the
     * {@link Identity} object holding that CA’s cryptographic material and metadata.
     * </p>
     */
    private Map<String, Identity> cas;

    /**
     * TLS identity used by Microfab for secure communications.
     * <p>
     * This typically represents a wildcard TLS certificate with a subject name
     * such as <code>*.127-0-0-1.nip.io</code>. It can be used by clients to
     * establish mutual TLS connections.
     * </p>
     */
    private Identity tls;

    /**
     * Factory method to create a {@code State} instance from a {@link JSONObject}.
     *
     * <p>This method expects a JSON structure similar to {@code state.json} produced by Microfab:
     * <pre>{@code
     * {
     *   "hash": "...",
     *   "cas": {
     *     "Orderer": { "id": "...", "display_name": "...", "type": "identity", ... },
     *     "Org1":    { "id": "...", "display_name": "...", "type": "identity", ... }
     *   },
     *   "tls": {
     *     "id": "...", "display_name": "...", "type": "identity", ...
     *   }
     * }
     * }</pre>
     *
     * @param json the JSON object representing the state file.
     * @return a populated {@link State} instance.
     */
    public static State from(JSONObject json) {
        State.Builder builder = State.builder()
                .hash(json.optString("hash"));
        JSONObject tls = json.optJSONObject("tls");
        builder.tls(isNull(tls) ? null : Identity.from(tls));
        JSONObject cas = json.optJSONObject("cas");
        builder.cas(cas.keySet()
                .stream()
                .map(ca -> Map.entry(ca, Identity.from(cas.getJSONObject(ca))))
                .collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue)));
        return builder.build();
    }

    /**
     * Represents an identity used for managing components inside
     * <a href="https://github.com/hyperledger-labs/microfab">Microfab</a>.
     *
     * <p>
     * This class is the Java representation of the
     * <code>Identity</code> structure from
     * <a href="https://github.com/hyperledger-labs/microfab/blob/main/pkg/client/client.go">
     * Microfab client</a>.
     * </p>
     *
     * <p>
     * An identity in Microfab encapsulates the credentials required to
     * interact with Fabric components such as peers, orderers, and CAs.
     * It includes cryptographic material (certificate, private key, and CA chain),
     * MSP identifier, and wallet association.
     * </p>
     *
     * <p>
     * Note: The original Go struct used <code>[]byte</code> for
     * {@code cert}, {@code private_key}, and {@code ca}. Here they are mapped to
     * {@link String} to hold PEM-encoded textual data.
     * </p>
     */
    @Data
    @lombok.Builder(builderClassName = "Builder")
    public static class Identity implements Jsonable {

        /**
         * Unique identifier for this identity inside Microfab.
         */
        private String id;

        /**
         * Human-readable display name for the identity.
         */
        @Getter(onMethod_ = @JSONPropertyName("display_name"))
        private String displayName;

        /**
         * Type of identity (e.g., admin, client).
         */
        private String type;

        /**
         * Base64 PEM-encoded X.509 certificate of the identity.
         */
        @Getter(onMethod_ = @JSONPropertyName("cert"))
        private String certificate;

        /**
         * Base64 PEM-encoded private key associated with the identity.
         */
        @Getter(onMethod_ = @JSONPropertyName("private_key"))
        private String privateKey;

        /**
         * Base64 PEM-encoded CA certificate chain that signed this identity.
         */
        private String ca;

        /**
         * MSP ID to which this identity belongs.
         */
        @Getter(onMethod_ = @JSONPropertyName("msp_id"))
        private String mspId;

        /**
         * Wallet name where this identity is stored.
         */
        private String wallet;

        /**
         * Factory method that creates an {@link Identity} instance from a
         * {@link JSONObject}.
         *
         * <p>
         * The JSON object is expected to follow the schema returned by Microfab's
         * <code>state.json</code> file for identities, containing keys such as
         * <code>id</code>, <code>display_name</code>, <code>type</code>,
         * <code>cert</code>, <code>private_key</code>, <code>ca</code>,
         * <code>msp_id</code>, and <code>wallet</code>.
         * </p>
         *
         * <h2>Example</h2>
         * <pre>{@code
         * JSONObject json = new JSONObject(stateJson).getJSONArray("identities").getJSONObject(0);
         * Identity identity = Identity.fromJson(json);
         * }</pre>
         *
         * @param json the JSON object representing an identity
         * @return a populated {@link Identity} instance
         */
        public static Identity from(JSONObject json) {
            return Identity.builder()
                    .id(json.optString("id", null))
                    .displayName(json.optString("display_name", null))
                    .type(json.optString("type", null))
                    .certificate(json.optString("cert", null))
                    .privateKey(json.optString("private_key", null))
                    .ca(json.optString("ca", null))
                    .mspId(json.optString("msp_id", null))
                    .wallet(json.optString("wallet", null))
                    .build();
        }

        /**
         * Returns the TLS certificate in PEM format.
         * <p>
         * The underlying {@code certificate} value is stored as a Base64-encoded string.
         * This method decodes it into its textual PEM representation.
         * </p>
         *
         * @return the decoded PEM string for the TLS certificate.
         * @throws IllegalArgumentException if the stored value is not valid Base64.
         */
        @JSONPropertyIgnore
        public String getCertificatePem() {
            return getPem(certificate);
        }

        /**
         * Returns the TLS private key in PEM format.
         * <p>
         * The underlying {@code privateKey} value is stored as a Base64-encoded string.
         * This method decodes it into its textual PEM representation.
         * </p>
         *
         * @return the decoded PEM string for the TLS private key.
         * @throws IllegalArgumentException if the stored value is not valid Base64.
         */
        @JSONPropertyIgnore
        public String getPrivateKeyPem() {
            return getPem(privateKey);
        }

        /**
         * Returns the TLS certificate authority (CA) certificate in PEM format.
         * <p>
         * The underlying {@code ca} value is stored as a Base64-encoded string.
         * This method decodes it into its textual PEM representation.
         * </p>
         *
         * @return the decoded PEM string for the CA certificate.
         * @throws IllegalArgumentException if the stored value is not valid Base64.
         */
        @JSONPropertyIgnore
        public String getCaPem() {
            return getPem(ca);
        }

        /**
         * Decodes a Base64-encoded string into its UTF-8 PEM representation.
         *
         * @param base64 the Base64-encoded value (non-null).
         * @return the decoded PEM string.
         * @throws IllegalArgumentException if {@code base64} is not valid Base64.
         */
        private String getPem(String base64) {
            return nonNull(base64) ? new String(Base64.getDecoder().decode(base64), UTF_8) : null;
        }
    }
}
