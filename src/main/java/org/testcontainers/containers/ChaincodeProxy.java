package org.testcontainers.containers;

import ir.co.isc.spbp.blockchain.microfab.MicrofabContainer;
import ir.co.isc.spbp.blockchain.microfab.model.Config;
import lombok.experimental.UtilityClass;

/**
 * Utility for exposing Microfab chaincode processes to the Docker network.
 * <p>
 * Chaincodes deployed in Microfab often run as external services (CCaaS).
 * To allow peer containers to connect securely, both the hostname and port
 * must be made available within the Docker network. This class performs
 * the following tasks for each configured chaincode:
 * </p>
 *
 * <ul>
 *   <li><b>Port forwarding:</b> Registers the chaincode’s port with
 *       {@link PortForwardingContainer#INSTANCE} so that it can be reached
 *       from other containers in the test network.</li>
 *   <li><b>Hostname mapping:</b> Adds an {@code extraHost} entry to the
 *       Microfab container, mapping {@code chaincodeName.localho.st} to the
 *       Docker host’s IP address. This ensures hostname resolution works
 *       consistently with the TLS certificates generated by Microfab
 *       (which include {@code *.localho.st} as a SAN).</li>
 * </ul>
 *
 * <h3>Example</h3>
 * If a chaincode named {@code mycc} runs at {@code localhost:9999}, this class ensures:
 * <pre>
 *   mycc.localho.st → 172.17.0.1   (inside Docker network)
 *   Port 9999 is exposed via {@link PortForwardingContainer#INSTANCE}.
 * </pre>
 *
 * <p>
 * This setup prevents DNS resolution errors and TLS hostname mismatches
 * when peers connect to external chaincode processes.
 * </p>
 *
 * @see PortForwardingContainer
 * @see MicrofabContainer
 */
@UtilityClass
public class ChaincodeProxy {

    /**
     * Expose the given chaincodes by forwarding their ports and
     * registering their {@code *.localho.st} hostnames inside the Microfab container.
     *
     * @param microfab   the Microfab container instance
     * @param chaincodes the chaincodes to expose
     */
    public void expose(MicrofabContainer<?> microfab, Config.Chaincode... chaincodes) {
        for (Config.Chaincode cc : chaincodes) {
            int port = cc.getPort();
            PortForwardingContainer.INSTANCE.exposeHostPort(port);
            PortForwardingContainer.INSTANCE.getNetwork()
                    .ifPresent(net -> microfab.withExtraHost("%s.localho.st".formatted(cc.getName()), net.getIpAddress()));
        }
    }

    /**
     * Terminates all chaincode host and port mappings created by this proxy.
     * <p>
     * This method delegates to {@link PortForwardingContainer#reset()} on
     * {@link PortForwardingContainer#INSTANCE}, which clears any port
     * forwarding rules that were previously established during chaincode
     * exposure (see {@link #expose(MicrofabContainer, Config.Chaincode...)}).
     * </p>
     *
     * <h3>When to use</h3>
     * <ul>
     *   <li>At the end of a test run, to ensure no stale mappings persist
     *       across subsequent test executions.</li>
     *   <li>When shutting down or reconfiguring Microfab, to restore the
     *       container’s network state to a clean baseline.</li>
     * </ul>
     *
     * <p>
     * Failing to call this method may leave dangling port forwards that
     * interfere with later chaincode deployments or cause unexpected
     * connectivity issues.
     * </p>
     *
     * @see #expose(MicrofabContainer, Config.Chaincode...)
     * @see PortForwardingContainer#reset()
     */
    public void terminate() {
        PortForwardingContainer.INSTANCE.reset();
    }
}
